#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Feb 28 14:32:30 2023

@author: nate
"""

import pandas as pd
import numpy as np

data=pd.read_csv(r'/Users/nate/Downloads/FakeBGO', delimiter=';', header=0) #download the file and put the path here

tol=1 #coincidence window
coincidences_index_0=[] #stores the index of non-coincidence interactions
coincidences_index_1=[] #stores the index of single coincidences
coincidences_index_2=[] #stores the index of double coincidences
coincidences_index_3=[] #stores the index of triple coincidences
detector_number=4 #number of detectors
detector_pos=[[1,1,1],[1,1,1],[1,1,1],[1,1,1]] #positions of detectors
skips=0 #when a multiple coincidence is detected, the next few data points don't need checking. skips counts this

for i in range(len(data.iloc[:,2])-3): #for all the data points
    if skips<1: #if we haven't already considered the ith data point
        if np.abs(data.iloc[i,2]-data.iloc[i+1,2]) < tol: #is the time diference between points less than the coincidence window
            if np.abs(data.iloc[i+1,2]-data.iloc[i+2,2]) < tol: #and the next one?
                if np.abs(data.iloc[i+2,2]-data.iloc[i+3,2]) < tol: #and the next one?
                    coincidences_index_3.append(i)
                    skips=4 #skip the next 3 (4-1) points
                else:
                    coincidences_index_2.append(i)
                    skips=3 
            else:
                coincidences_index_1.append(i)
                skips=2
        else:
            coincidences_index_0.append(i)
    skips-=1
                
interaction_energies=[] #energies of interactions
interaction_locations=[] #locations of interactions
cal_grad=[1,1,1,1] #list of gradients of the calibration for each detector
cal_intercept=[0,0,0,0] #list of intercepts of the calibration for each detector

for index_index, coincidence_index in enumerate(coincidences_index_0): #for all the not coincidences
    E0=(data.iloc[coincidence_index,3]-cal_intercept[data.iloc[coincidence_index,1]])/cal_grad[data.iloc[coincidence_index,1]]
    interaction_energies.append(E0) #the energy is just the energy in the detector
    interaction_locations.append(detector_pos[data.iloc[coincidence_index,1]]) #the location is just the location of the detector

for index_index, coincidence_index in enumerate(coincidences_index_1): #for all the coincidences
    E0=(data.iloc[coincidence_index,3]-cal_intercept[data.iloc[coincidence_index,1]])/cal_grad[data.iloc[coincidence_index,1]]
    E1=(data.iloc[coincidence_index+1,3]-cal_intercept[data.iloc[coincidence_index+1,1]])/cal_grad[data.iloc[coincidence_index+1,1]]
    energy=E0+E1 #energy is sum of all energies
    interaction_energies.append(energy)
    location_x=E0*detector_pos[data.iloc[coincidence_index,1]][0]+E1*detector_pos[data.iloc[coincidence_index+1,1]][0] #anger logic
    location_y=E0*detector_pos[data.iloc[coincidence_index,1]][1]+E1*detector_pos[data.iloc[coincidence_index+1,1]][1]
    location_z=E0*detector_pos[data.iloc[coincidence_index,1]][2]+E1*detector_pos[data.iloc[coincidence_index+1,1]][2]
    location=[location_x/energy,location_y/energy,location_z/energy]
    interaction_locations.append(location)
    
for index_index, coincidence_index in enumerate(coincidences_index_2): #for all the coincidences
    E0=(data.iloc[coincidence_index,3]-cal_intercept[data.iloc[coincidence_index,1]])/cal_grad[data.iloc[coincidence_index,1]]
    E1=(data.iloc[coincidence_index+1,3]-cal_intercept[data.iloc[coincidence_index+1,1]])/cal_grad[data.iloc[coincidence_index+1,1]]
    E2=(data.iloc[coincidence_index+2,3]-cal_intercept[data.iloc[coincidence_index+2,1]])/cal_grad[data.iloc[coincidence_index+2,1]]
    energy=E0+E1+E2 #energy is sum of all energies
    interaction_energies.append(energy)
    location_x=E0*detector_pos[data.iloc[coincidence_index,1]][0]+E1*detector_pos[data.iloc[coincidence_index+1,1]][0]+E2*detector_pos[data.iloc[coincidence_index+2,1]][0]
    location_y=E0*detector_pos[data.iloc[coincidence_index,1]][1]+E1*detector_pos[data.iloc[coincidence_index+1,1]][1]+E2*detector_pos[data.iloc[coincidence_index+2,1]][1]
    location_z=E0*detector_pos[data.iloc[coincidence_index,1]][2]+E1*detector_pos[data.iloc[coincidence_index+1,1]][2]+E2*detector_pos[data.iloc[coincidence_index+2,1]][2]
    location=[location_x/energy,location_y/energy,location_z/energy]
    interaction_locations.append(location)

for index_index, coincidence_index in enumerate(coincidences_index_3): #for all the coincidences
    E0=(data.iloc[coincidence_index,3]-cal_intercept[data.iloc[coincidence_index,1]])/cal_grad[data.iloc[coincidence_index,1]]
    E1=(data.iloc[coincidence_index+1,3]-cal_intercept[data.iloc[coincidence_index+1,1]])/cal_grad[data.iloc[coincidence_index+1,1]]
    E2=(data.iloc[coincidence_index+2,3]-cal_intercept[data.iloc[coincidence_index+2,1]])/cal_grad[data.iloc[coincidence_index+2,1]]
    E3=(data.iloc[coincidence_index+3,3]-cal_intercept[data.iloc[coincidence_index+3,1]])/cal_grad[data.iloc[coincidence_index+3,1]]
    energy=E0+E1+E2+E3 #energy is sum of all energies
    interaction_energies.append(energy)
    location_x=E0*detector_pos[data.iloc[coincidence_index,1]][0]+E1*detector_pos[data.iloc[coincidence_index+1,1]][0]+E2*detector_pos[data.iloc[coincidence_index+2,1]][0]+E3*detector_pos[data.iloc[coincidence_index+3,1]][0]
    location_y=E0*detector_pos[data.iloc[coincidence_index,1]][1]+E1*detector_pos[data.iloc[coincidence_index+1,1]][1]+E2*detector_pos[data.iloc[coincidence_index+2,1]][1]+E3*detector_pos[data.iloc[coincidence_index+3,1]][1]
    location_z=E0*detector_pos[data.iloc[coincidence_index,1]][2]+E1*detector_pos[data.iloc[coincidence_index+1,1]][2]+E2*detector_pos[data.iloc[coincidence_index+2,1]][2]+E3*detector_pos[data.iloc[coincidence_index+3,1]][2]
    location=[location_x/energy,location_y/energy,location_z/energy]
    interaction_locations.append(location)

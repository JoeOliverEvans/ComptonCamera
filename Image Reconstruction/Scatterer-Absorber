#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Mar 19 17:52:33 2023

@author: nate
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Feb 21 14:24:47 2023

@author: nate
"""


import pandas as pd
import numpy as np
import scipy.constants as constants
from datetime import datetime

#rows=1000000


data=pd.read_csv(r'/Users/nate/Downloads/DataR_24martwosourcessameplane (1).CSV', delimiter=';', header=0)
data=data.sort_values(by=['TIMETAG']) 


tol=200000 #coincidence window in picoseconds/monte carlo timestamp units
coincidences_index=[] #stores the index of coincidences
detector_number=8 #number of detectors

detector_pos=[np.array([-9.9, 15.8, 6.4]),np.array([-12.1, -24.5, 4.0]),np.array([18, -24.2, 6.6]),np.array([17.6, 13.6, 8.2]),np.array([-11.2, -0.3, 79.2]),np.array([2.8, 14.6, 78.9]),np.array([16.3, -0.4, 78.8]),np.array([2.3, -14.6, 78.2])]

Ei=0.662 #initial energy in MeV
gap=0.01 #tolerance for absorption in MeV/typical energy spread


for i in range(len(data.iloc[:,2])-1): #for all the data points
    if np.abs(data.iloc[i,2]-data.iloc[i+1,2]) < tol: #is the time diference between points less than the coincidence window
        coincidences_index.append(i)
        


scattera_energies=[] #energies of scatters followed by absorptions
scattera_locations=[] #locations of scatters followed by absorptions
absorption_energies=[] #energies of absorptions
absorption_locations=[] #locations of absorptions
scatters_energies=[] #energies of scatters followed by scatters
scatters_locations=[] #locations of scatters followed by scatters
scatter2_energies=[] #energies of second scatters
scatter2_locations=[] #locations of second scatters
lost=[] #coincidences that couldn't be sorted

electron_mass = (constants.electron_mass * constants.c ** 2)/ (constants.electron_volt * 10 ** 6)  # in MeV


    

cal_grad=[2440,2430,2470,2370,720,747,687,710] #list of gradients of the calibration for each detector
cal_intercept=[148.0,146.5,156.1,127.8,73.0,41.4,73.4,702.2] #list of intercepts of the calibration for each detector
              
for index_index, coincidence_index in enumerate(coincidences_index): #for all the coincidences
    for i in range(detector_number):
        for j in range(detector_number): 
            if data.iloc[coincidence_index,1]==i: #if the coincidence was registered in detector i
                if data.iloc[coincidence_index+1,1]==j: #if the second detector involved was detector j
                    E0=(data.iloc[coincidence_index,3]-cal_intercept[i])/cal_grad[i]
                    E1=(data.iloc[coincidence_index+1,3]-cal_intercept[j])/cal_grad[j]
                    if -1<i<4 and 3<j<8 and E0<Ei+gap: #if i is scatterer and j is absorber
                        if np.abs(E0+E1-Ei)<gap: #if scatter-absorption
                            scattera_energies.append(E0) #add scatter energy to list
                            scattera_locations.append(detector_pos[i]) #add scatter location to list
                            absorption_energies.append(E1) #add absorption energy to list
                            absorption_locations.append(detector_pos[j]) #add absorption locator to list
                        else: #if scatter-scatter
                            scatters_energies.append(E0) #add scatter 1 energy to list
                            scatters_locations.append(detector_pos[i]) #add scatter 1 location to list
                            scatter2_energies.append(E1) #add scatter 2 energy to list
                            scatter2_locations.append(detector_pos[j]) #add scatter 2 locator to list
                    elif -1<j<4 and 3<i<8 and E1<Ei+gap: #if i is scatterer and j is absorber
                        if np.abs(E0+E1-Ei)<gap:
                            scattera_energies.append(E1) #add scatter energy to list
                            scattera_locations.append(detector_pos[j]) #add scatter location to list
                            absorption_energies.append(E0) #add absorption energy to list
                            absorption_locations.append(detector_pos[i]) #add absorption location to list
                        else:
                            scatters_energies.append(E1) #add scatter 1 energy to list
                            scatters_locations.append(detector_pos[j]) #add scatter 1 location to list
                            scatter2_energies.append(E0) #add scatter 2 energy to list
                            scatter2_locations.append(detector_pos[i]) #add scatter 2 location to list
                    else:
                       lost.append(coincidence_index)
'''                
#2nd file

data=pd.read_csv(r'/Users/nate/Downloads/DataR_24thmarstrongestsourcefinal_1.CSV', delimiter=';', header=0) #download the file and put the path here
data=data.sort_values(by=['TIMETAG']) 

for i in range(len(data.iloc[:,2])-1): #for all the data points
    if np.abs(data.iloc[i,2]-data.iloc[i+1,2]) < tol: #is the time diference between points less than the coincidence window
        coincidences_index.append(i)
        
              
for index_index, coincidence_index in enumerate(coincidences_index): #for all the coincidences
    for i in range(detector_number):
        for j in range(detector_number): 
            if data.iloc[coincidence_index,1]==i: #if the coincidence was registered in detector i
                if data.iloc[coincidence_index+1,1]==j: #if the second detector involved was detector j
                    E0=(data.iloc[coincidence_index,3]-cal_intercept[i])/cal_grad[i]
                    E1=(data.iloc[coincidence_index+1,3]-cal_intercept[j])/cal_grad[j]
                    if -1<i<4 and 3<j<8 : #if i is scatterer and j is absorber
                        if np.abs(E0+E1-Ei)<gap: #if scatter-absorption
                            scattera_energies.append(E0) #add scatter energy to list
                            scattera_locations.append(detector_pos[i]) #add scatter location to list
                            absorption_energies.append(E1) #add absorption energy to list
                            absorption_locations.append(detector_pos[j]) #add absorption locator to list
                        else: #if scatter-scatter
                            scatters_energies.append(E0) #add scatter 1 energy to list
                            scatters_locations.append(detector_pos[i]) #add scatter 1 location to list
                            scatter2_energies.append(E1) #add scatter 2 energy to list
                            scatter2_locations.append(detector_pos[j]) #add scatter 2 locator to list
                    elif -1<j<4 and 3<i<8 : #if i is scatterer and j is absorber
                        if np.abs(E0+E1-Ei)<gap:
                            scattera_energies.append(E1) #add scatter energy to list
                            scattera_locations.append(detector_pos[j]) #add scatter location to list
                            absorption_energies.append(E0) #add absorption energy to list
                            absorption_locations.append(detector_pos[i]) #add absorption location to list
                        else:
                            scatters_energies.append(E1) #add scatter 1 energy to list
                            scatters_locations.append(detector_pos[j]) #add scatter 1 location to list
                            scatter2_energies.append(E0) #add scatter 2 energy to list
                            scatter2_locations.append(detector_pos[i]) #add scatter 2 location to list
                    else:
                        lost.append(coincidence_index)
                        

'''                      

#timedate = datetime.now().strftime("%d/%m/%Y %H:%M:%S").replace('/', ':').replace(':', '-')
timedate='24thMarScatterAbsorb'
# dictionary of lists  
dict = {'scatter energy': scattera_energies, 'scatter locations': scattera_locations, 'absorption energies': absorption_energies, 'absorption locations': absorption_locations}    
       
df = pd.DataFrame(dict) 
    
# saving the dataframe 
df.to_csv(f'experimentalabsorptionscatter{timedate}.csv')
df.to_parquet(f'experimentalabsorptionscatter{timedate}.parquet')

# dictionary of lists  
dict = {'scatter energy': scatters_energies, 'scatter locations': scatters_locations, 'absorption energies': scatter2_energies, 'absorption locations': scatter2_locations}    
       
df = pd.DataFrame(dict) 
    
# saving the dataframe 
df.to_csv(f'experimentalscattercatter{timedate}.csv')
df.to_parquet(f'experimentalscatterscatter{timedate}.parquet')
                        